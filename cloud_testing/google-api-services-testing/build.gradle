plugins {
    // https://github.com/diffplug/spotless/tree/master/plugin-gradle
    id 'com.diffplug.gradle.spotless' version '3.4.0'
}

/*
<groupId>com.google.apis</groupId>
<artifactId>google-api-services-testing</artifactId>
<version>v1-revsnapshot-1.20.0</version>
*/
group 'com.google.apis'
version 'v1-revsnapshot-1.20.0'

apply plugin: 'java'

apply plugin: 'com.diffplug.gradle.spotless'
spotless { // gradle spotlessApply
    java {
        googleJavaFormat()
    }
}

repositories {
    mavenCentral()
}

dependencies {
    compile 'com.google.api-client:google-api-client:1.20.0'
}

def jarName = 'google-api-services-testing-v1-revsnapshot-1.20.0.jar'
def inputJar = "../lib/$jarName"
def outputDir = './src/main/java'

task decompileCfr(type: Exec) {
    //noinspection GroovyAssignabilityCheck
    executable 'java'

    def classPathBuilder = StringBuilder.newInstance()
    configurations.runtime.each { classPathBuilder.append(it.absolutePath).append(':') }
    classPathBuilder.deleteCharAt(classPathBuilder.size() - 1) // remove trailing :
    def classPathStr = classPathBuilder.toString()

    // make sure code only runs when we invoke the task.
    // without doFirst the code is always run as part of the gradle configuration phase.
    doFirst {
        // Clean up old files before decompiling.
        File.newInstance(outputDir).deleteDir()
    }

    //noinspection GroovyAssignabilityCheck
    // note: do not quote arguments! "\"$classPathStr\"" will silently discard the class path.
    args = ['-jar', '../cfr/cfr_0_121.jar',
            inputJar,
            '--extraclasspath', "$classPathStr",
            '--outputdir', outputDir,
            '--caseinsensitivefs', 'true']
}

// Use rerun task flag to ensure spotless runs
//
// gradle --rerun-tasks decompileCfr
// gradle --rerun-tasks decompileFern
afterEvaluate {
    decompileCfr.finalizedBy spotlessApply

    decompileFern.finalizedBy extractFern
    extractFern.finalizedBy spotlessApply
}

task decompileFern(type: Exec) {
    def args_array = ['-jar', '../fernflower/fernflower.jar', '-dgs=1']
    configurations.runtime.each { args_array.add('-e=' + it.absolutePath) }
    args_array.add(inputJar)
    args_array.add(outputDir)

    executable 'java'
    args = args_array
}

task extractFern(type: Exec) {
    def jarDir = './src/main/java'
    workingDir jarDir
    executable 'jar'
    args = ['xf', jarName]

    doLast {
        // fernflower always outputs a jar. clean it up after extracting.
        File.newInstance("$jarDir/META-INF").deleteDir()
        File.newInstance("$jarDir/summary.txt").delete()
        File.newInstance("$jarDir/$jarName").delete()
    }
}
